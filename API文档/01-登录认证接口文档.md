# 🔐 登录认证接口文档

## 📋 文档信息

- **模块名称**: 登录认证模块
- **创建时间**: 2025-01-17
- **版本**: v1.0
- **框架**: RuoYi-Vue
- **后端语言**: Java + Spring Boot
- **前端对应**: 01-登录页面设计文档

## 🎯 接口概览

| 序号 | 接口名称 | 请求方式 | 接口地址 | 说明 |
|------|----------|----------|----------|------|
| 1 | 账号密码登录 | POST | `/auth/login` | 用户名密码登录 |
| 2 | 手机验证码登录 | POST | `/auth/smsLogin` | 手机号验证码登录 |
| 3 | 发送验证码 | POST | `/auth/sendSms` | 发送手机验证码 |
| 4 | 退出登录 | POST | `/auth/logout` | 用户退出登录 |
| 5 | 刷新Token | POST | `/auth/refresh` | 刷新访问令牌 |
| 6 | 获取用户信息 | GET | `/auth/getInfo` | 获取当前用户信息 |
| 7 | 修改密码 | PUT | `/auth/changePassword` | 首次登录修改密码 |
| 8 | 获取登录历史 | GET | `/auth/loginHistory` | 获取用户登录历史记录 |

## 🔑 1. 账号密码登录

### 接口信息
- **接口地址**: `/auth/login`
- **请求方式**: POST
- **接口描述**: 用户使用用户名和密码进行登录认证

### 请求参数

```json
{
  "username": "admin",
  "password": "admin123",
  "code": "1234",
  "uuid": "verification_uuid"
}
```

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| username | String | 是 | 用户名/工号 |
| password | String | 是 | 密码(MD5加密) |
| code | String | 否 | 图形验证码 |
| uuid | String | 否 | 验证码UUID |

### 响应参数

**成功响应**:
```json
{
  "code": 200,
  "msg": "操作成功",
  "data": {
    "token": "eyJhbGciOiJIUzUxMiJ9...",
    "user": {
      "userId": 1,
      "username": "admin",
      "nickName": "管理员",
      "email": "admin@example.com",
      "phonenumber": "13800138000",
      "sex": "1",
      "avatar": "",
      "deptId": 103,
      "deptName": "研发部门",
      "roleIds": [1],
      "roles": ["admin"],
      "permissions": ["*:*:*"],
      "isFirstLogin": false,
      "lastLoginTime": "2025-01-17 10:30:00",
      "lastLoginIp": "192.168.1.100"
    }
  }
}
```

**失败响应**:
```json
{
  "code": 500,
  "msg": "用户名或密码错误",
  "data": null
}
```

### Java Controller实现

```java
@RestController
@RequestMapping("/auth")
@Api(tags = "登录认证接口")
public class SysLoginController extends BaseController {
    
    @Autowired
    private SysLoginService loginService;
    
    @Autowired
    private ISysUserService userService;
    
    /**
     * 登录方法
     */
    @PostMapping("/login")
    @ApiOperation("用户登录")
    public AjaxResult login(@RequestBody LoginBody loginBody) {
        AjaxResult ajax = AjaxResult.success();
        // 生成令牌
        String token = loginService.login(loginBody.getUsername(), 
                                         loginBody.getPassword(), 
                                         loginBody.getCode(), 
                                         loginBody.getUuid());
        ajax.put(Constants.TOKEN, token);
        
        // 获取用户信息
        LoginUser loginUser = tokenService.getLoginUser(ServletUtils.getRequest());
        SysUser user = loginUser.getUser();
        ajax.put("user", user);
        
        return ajax;
    }
}
```

### 业务逻辑实现

```java
@Service
public class SysLoginService {
    
    @Autowired
    private TokenService tokenService;
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private RedisCache redisCache;
    
    /**
     * 登录验证
     */
    public String login(String username, String password, String code, String uuid) {
        // 验证码校验
        validateCaptcha(username, code, uuid);
        
        // 登录前置校验
        loginPreCheck(username, password);
        
        // 用户验证
        Authentication authentication = null;
        try {
            UsernamePasswordAuthenticationToken authenticationToken = 
                new UsernamePasswordAuthenticationToken(username, password);
            AuthContextHolder.setContext(authenticationToken);
            // 该方法会去调用UserDetailsServiceImpl.loadUserByUsername
            authentication = authenticationManager.authenticate(authenticationToken);
        } catch (Exception e) {
            if (e instanceof BadCredentialsException) {
                AsyncManager.me().execute(AsyncFactory.recordLogininfor(
                    username, Constants.LOGIN_FAIL, MessageUtils.message("user.password.not.match")));
                throw new UserPasswordNotMatchException();
            } else {
                AsyncManager.me().execute(AsyncFactory.recordLogininfor(
                    username, Constants.LOGIN_FAIL, e.getMessage()));
                throw new ServiceException(e.getMessage());
            }
        } finally {
            AuthContextHolder.clearContext();
        }
        
        AsyncManager.me().execute(AsyncFactory.recordLogininfor(
            username, Constants.LOGIN_SUCCESS, MessageUtils.message("user.login.success")));
        
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        recordLoginInfo(loginUser.getUserId());
        
        // 生成token
        return tokenService.createToken(loginUser);
    }
    
    /**
     * 校验验证码
     */
    public void validateCaptcha(String username, String code, String uuid) {
        String verifyKey = CacheConstants.CAPTCHA_CODE_KEY + StringUtils.nvl(uuid, "");
        String captcha = redisCache.getCacheObject(verifyKey);
        redisCache.deleteObject(verifyKey);
        
        if (captcha == null) {
            AsyncManager.me().execute(AsyncFactory.recordLogininfor(
                username, Constants.LOGIN_FAIL, MessageUtils.message("user.jcaptcha.expire")));
            throw new CaptchaExpireException();
        }
        
        if (!code.equalsIgnoreCase(captcha)) {
            AsyncManager.me().execute(AsyncFactory.recordLogininfor(
                username, Constants.LOGIN_FAIL, MessageUtils.message("user.jcaptcha.error")));
            throw new CaptchaException();
        }
    }
}
```

## 📱 2. 手机验证码登录

### 接口信息
- **接口地址**: `/auth/smsLogin`
- **请求方式**: POST
- **接口描述**: 用户使用手机号和验证码进行登录

### 请求参数

```json
{
  "phone": "13800138000",
  "code": "123456"
}
```

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| phone | String | 是 | 手机号码(11位) |
| code | String | 是 | 短信验证码(6位) |

### 响应参数

**成功响应**: 同账号密码登录
**失败响应**: 
```json
{
  "code": 500,
  "msg": "验证码错误或已过期",
  "data": null
}
```

### Java实现

```java
/**
 * 手机验证码登录
 */
@PostMapping("/smsLogin")
@ApiOperation("手机验证码登录")
public AjaxResult smsLogin(@RequestBody SmsLoginBody smsLoginBody) {
    AjaxResult ajax = AjaxResult.success();
    
    // 验证码校验
    String verifyKey = CacheConstants.SMS_CODE_KEY + smsLoginBody.getPhone();
    String smsCode = redisCache.getCacheObject(verifyKey);
    
    if (StringUtils.isEmpty(smsCode)) {
        return error("验证码已过期，请重新获取");
    }
    
    if (!smsLoginBody.getCode().equals(smsCode)) {
        return error("验证码错误");
    }
    
    // 根据手机号查找用户
    SysUser user = userService.selectUserByPhonenumber(smsLoginBody.getPhone());
    if (StringUtils.isNull(user)) {
        return error("该手机号未绑定用户");
    }
    
    // 生成token
    LoginUser loginUser = new LoginUser(user.getUserId(), user.getDeptId(), user, null);
    String token = tokenService.createToken(loginUser);
    
    ajax.put(Constants.TOKEN, token);
    ajax.put("user", user);
    
    // 删除验证码
    redisCache.deleteObject(verifyKey);
    
    // 记录登录日志
    AsyncManager.me().execute(AsyncFactory.recordLogininfor(
        user.getUserName(), Constants.LOGIN_SUCCESS, "手机验证码登录成功"));
    
    return ajax;
}
```

## 📨 3. 发送验证码

### 接口信息
- **接口地址**: `/auth/sendSms`
- **请求方式**: POST
- **接口描述**: 向指定手机号发送登录验证码

### 请求参数

```json
{
  "phone": "13800138000"
}
```

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| phone | String | 是 | 手机号码(11位) |

### 响应参数

```json
{
  "code": 200,
  "msg": "验证码发送成功",
  "data": {
    "countdown": 60
  }
}
```

### Java实现

```java
/**
 * 发送短信验证码
 */
@PostMapping("/sendSms")
@ApiOperation("发送短信验证码")
public AjaxResult sendSms(@RequestBody Map<String, String> params) {
    String phone = params.get("phone");
    
    // 手机号格式验证
    if (!RegexUtils.isPhoneNumber(phone)) {
        return error("手机号格式不正确");
    }
    
    // 检查发送频率限制
    String rateKey = CacheConstants.SMS_RATE_KEY + phone;
    String lastSendTime = redisCache.getCacheObject(rateKey);
    if (StringUtils.isNotEmpty(lastSendTime)) {
        return error("验证码发送过于频繁，请稍后再试");
    }
    
    // 生成6位数字验证码
    String code = RandomUtil.randomNumbers(6);
    
    // 发送短信
    try {
        boolean success = smsService.sendLoginCode(phone, code);
        if (!success) {
            return error("验证码发送失败，请稍后重试");
        }
        
        // 缓存验证码，5分钟有效
        redisCache.setCacheObject(CacheConstants.SMS_CODE_KEY + phone, code, 5, TimeUnit.MINUTES);
        
        // 设置发送频率限制，60秒内不可重复发送
        redisCache.setCacheObject(rateKey, String.valueOf(System.currentTimeMillis()), 60, TimeUnit.SECONDS);
        
        return success("验证码发送成功").put("countdown", 60);
        
    } catch (Exception e) {
        log.error("发送短信验证码异常", e);
        return error("验证码发送失败");
    }
}

@Service
public class SmsServiceImpl implements SmsService {
    
    /**
     * 发送登录验证码
     */
    @Override
    public boolean sendLoginCode(String phone, String code) {
        try {
            // 这里接入具体的短信服务商API
            // 如阿里云短信、腾讯云短信等
            String templateCode = "SMS_LOGIN_CODE";
            String templateParam = "{\"code\":\"" + code + "\"}";
            
            // 调用短信服务
            return aliSmsClient.sendSms(phone, templateCode, templateParam);
            
        } catch (Exception e) {
            log.error("发送短信验证码失败：phone={}, code={}", phone, code, e);
            return false;
        }
    }
}
```

## 🚪 4. 退出登录

### 接口信息
- **接口地址**: `/auth/logout`
- **请求方式**: POST
- **接口描述**: 用户退出登录，清除token

### 请求参数

```json
{}
```

### 响应参数

```json
{
  "code": 200,
  "msg": "退出成功",
  "data": null
}
```

### Java实现

```java
/**
 * 退出登录
 */
@PostMapping("/logout")
@ApiOperation("退出登录")
public AjaxResult logout() {
    LoginUser loginUser = tokenService.getLoginUser(ServletUtils.getRequest());
    if (StringUtils.isNotNull(loginUser)) {
        String userName = loginUser.getUsername();
        // 删除用户缓存记录
        tokenService.delLoginUser(loginUser.getToken());
        // 记录用户退出日志
        AsyncManager.me().execute(AsyncFactory.recordLogininfor(
            userName, Constants.LOGOUT, "退出成功"));
    }
    return success("退出成功");
}
```

## 🔄 5. 刷新Token

### 接口信息
- **接口地址**: `/auth/refresh`
- **请求方式**: POST
- **接口描述**: 刷新访问令牌，延长登录有效期

### 请求参数
```json
{}
```

### 响应参数
```json
{
  "code": 200,
  "msg": "刷新成功",
  "data": {
    "token": "new_token_value"
  }
}
```

### Java实现

```java
/**
 * 刷新令牌
 */
@PostMapping("/refresh")
@ApiOperation("刷新令牌")
public AjaxResult refresh(HttpServletRequest request) {
    LoginUser loginUser = tokenService.getLoginUser(request);
    if (StringUtils.isNotNull(loginUser)) {
        // 刷新令牌有效期
        tokenService.refreshToken(loginUser);
        return success().put("token", loginUser.getToken());
    }
    return error("令牌已过期");
}
```

## 👤 6. 获取用户信息

### 接口信息
- **接口地址**: `/auth/getInfo`
- **请求方式**: GET
- **接口描述**: 获取当前登录用户的详细信息

### 请求参数
无需请求参数，从token中获取用户信息

### 响应参数

```json
{
  "code": 200,
  "msg": "操作成功",
  "data": {
    "user": {
      "userId": 1,
      "username": "admin",
      "nickName": "管理员",
      "email": "admin@example.com",
      "phonenumber": "13800138000",
      "sex": "1",
      "avatar": "",
      "deptId": 103,
      "deptName": "研发部门"
    },
    "roles": ["admin", "common"],
    "permissions": ["*:*:*"]
  }
}
```

### Java实现

```java
/**
 * 获取用户信息
 */
@GetMapping("/getInfo")
@ApiOperation("获取用户信息")
public AjaxResult getInfo() {
    SysUser user = SecurityUtils.getLoginUser().getUser();
    // 角色集合
    Set<String> roles = permissionService.getRolePermission(user);
    // 权限集合
    Set<String> permissions = permissionService.getMenuPermission(user);
    
    AjaxResult ajax = AjaxResult.success();
    ajax.put("user", user);
    ajax.put("roles", roles);
    ajax.put("permissions", permissions);
    return ajax;
}
```

## 🔐 7. 修改密码

### 接口信息
- **接口地址**: `/auth/changePassword`
- **请求方式**: PUT
- **接口描述**: 首次登录或用户主动修改密码

### 请求参数

```json
{
  "oldPassword": "admin123",
  "newPassword": "newpassword123",
  "confirmPassword": "newpassword123"
}
```

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| oldPassword | String | 否 | 原密码(首次登录可为空) |
| newPassword | String | 是 | 新密码 |
| confirmPassword | String | 是 | 确认密码 |

### 响应参数

```json
{
  "code": 200,
  "msg": "密码修改成功",
  "data": null
}
```

### Java实现

```java
/**
 * 修改密码
 */
@PutMapping("/changePassword")
@ApiOperation("修改密码")
public AjaxResult changePassword(@RequestBody ChangePasswordBody body) {
    LoginUser loginUser = SecurityUtils.getLoginUser();
    SysUser user = loginUser.getUser();
    
    String userName = user.getUserName();
    String password = user.getPassword();
    
    // 非首次登录需要验证原密码
    if (!user.getIsFirstLogin() && StringUtils.isNotEmpty(body.getOldPassword())) {
        if (!SecurityUtils.matchesPassword(body.getOldPassword(), password)) {
            return error("修改密码失败，旧密码错误");
        }
    }
    
    // 验证新密码
    if (!body.getNewPassword().equals(body.getConfirmPassword())) {
        return error("新密码和确认密码不一致");
    }
    
    // 密码强度校验
    if (!isValidPassword(body.getNewPassword())) {
        return error("密码强度不够，请使用8-20位字母数字组合");
    }
    
    // 更新密码
    if (userService.resetUserPwd(userName, SecurityUtils.encryptPassword(body.getNewPassword())) > 0) {
        // 更新首次登录标识
        if (user.getIsFirstLogin()) {
            user.setIsFirstLogin(false);
            userService.updateUser(user);
        }
        
        // 记录操作日志
        AsyncManager.me().execute(AsyncFactory.recordLogininfor(
            userName, Constants.LOGIN_SUCCESS, "密码修改成功"));
        
        return success("密码修改成功");
    }
    return error("密码修改失败，请联系管理员");
}

/**
 * 密码强度校验
 */
private boolean isValidPassword(String password) {
    if (StringUtils.isEmpty(password) || password.length() < 8 || password.length() > 20) {
        return false;
    }
    
    // 至少包含字母和数字
    boolean hasLetter = password.matches(".*[a-zA-Z].*");
    boolean hasDigit = password.matches(".*\\d.*");
    
    return hasLetter && hasDigit;
}
```

## 📋 8. 获取登录历史

### 接口信息
- **接口地址**: `/auth/loginHistory`
- **请求方式**: GET
- **接口描述**: 获取用户最近的登录历史记录

### 请求参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| pageNum | Integer | 否 | 页码，默认1 |
| pageSize | Integer | 否 | 每页数量，默认10 |

### 响应参数

```json
{
  "code": 200,
  "msg": "查询成功",
  "data": {
    "total": 25,
    "rows": [
      {
        "infoId": 1,
        "userName": "admin",
        "ipaddr": "192.168.1.100",
        "loginLocation": "内网IP",
        "browser": "Chrome 120",
        "os": "Windows 10",
        "status": "0",
        "msg": "登录成功",
        "loginTime": "2025-01-17 10:30:00",
        "isAbnormal": false
      }
    ]
  }
}
```

### Java实现

```java
/**
 * 获取登录历史
 */
@GetMapping("/loginHistory")
@ApiOperation("获取登录历史")
public TableDataInfo loginHistory(SysLogininfor logininfor) {
    SysUser currentUser = SecurityUtils.getLoginUser().getUser();
    logininfor.setUserName(currentUser.getUserName());
    
    startPage();
    List<SysLogininfor> list = logininforService.selectLogininforList(logininfor);
    
    // 标记异常IP
    for (SysLogininfor log : list) {
        log.setAbnormal(isAbnormalIp(log.getIpaddr(), currentUser.getUserName()));
    }
    
    return getDataTable(list);
}

/**
 * 判断是否为异常IP
 */
private boolean isAbnormalIp(String ipaddr, String userName) {
    // 获取用户常用IP列表
    List<String> commonIps = userService.getCommonIps(userName);
    
    // 检查是否为常用IP
    if (!commonIps.contains(ipaddr)) {
        // 检查IP地理位置是否异常
        String location = IpUtils.getRealAddressByIP(ipaddr);
        return isAbnormalLocation(location, userName);
    }
    
    return false;
}
```

## 🛡️ 安全配置

### Token配置

```java
@Component
public class TokenService {
    
    // 令牌自定义标识
    @Value("${token.header}")
    private String header;
    
    // 令牌秘钥
    @Value("${token.secret}")
    private String secret;
    
    // 令牌有效期（默认30分钟）
    @Value("${token.expireTime}")
    private int expireTime;
    
    /**
     * 创建令牌
     */
    public String createToken(LoginUser loginUser) {
        String token = IdUtils.fastUUID();
        loginUser.setToken(token);
        refreshToken(loginUser);
        
        Map<String, Object> claims = new HashMap<>();
        claims.put(Constants.LOGIN_USER_KEY, token);
        return createToken(claims);
    }
    
    /**
     * 验证令牌有效期，相差不足20分钟，自动刷新缓存
     */
    public void verifyToken(LoginUser loginUser) {
        long expireTime = loginUser.getExpireTime();
        long currentTime = System.currentTimeMillis();
        if (expireTime - currentTime <= MILLIS_MINUTE_TEN) {
            refreshToken(loginUser);
        }
    }
}
```

### 密码策略配置

```java
@Configuration
public class SecurityConfig {
    
    /**
     * 密码加密方式
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    /**
     * 认证失败处理类
     */
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return new AuthenticationEntryPointImpl();
    }
    
    /**
     * 权限不足处理类
     */
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return new AccessDeniedHandlerImpl();
    }
}
```

## 🔧 异常处理

### 自定义异常类

```java
/**
 * 用户密码不正确或不符合规范异常类
 */
public class UserPasswordNotMatchException extends UserException {
    public UserPasswordNotMatchException() {
        super("user.password.not.match", null);
    }
}

/**
 * 验证码错误异常类
 */
public class CaptchaException extends UserException {
    public CaptchaException() {
        super("user.jcaptcha.error", null);
    }
}

/**
 * 验证码失效异常类
 */
public class CaptchaExpireException extends UserException {
    public CaptchaExpireException() {
        super("user.jcaptcha.expire", null);
    }
}
```

### 全局异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /**
     * 用户认证异常
     */
    @ExceptionHandler(UserException.class)
    public AjaxResult handleUserException(UserException e) {
        String message = MessageUtils.message(e.getMessage(), e.getArgs());
        return AjaxResult.error(message);
    }
    
    /**
     * 认证失败
     */
    @ExceptionHandler(AuthenticationException.class)
    public AjaxResult handleAuthenticationException(AuthenticationException e) {
        return AjaxResult.error("认证失败，请重新登录");
    }
}
```

## 📊 接口状态码说明

| 状态码 | 说明 | 备注 |
|--------|------|------|
| 200 | 操作成功 | 正常响应 |
| 401 | 认证失败 | 未登录或token过期 |
| 403 | 权限不足 | 已登录但权限不够 |
| 500 | 系统异常 | 服务器内部错误 |
| 5001 | 用户名或密码错误 | 登录凭证错误 |
| 5002 | 验证码错误 | 图形或短信验证码错误 |
| 5003 | 验证码已过期 | 验证码超时 |
| 5004 | 账户已被禁用 | 用户状态异常 |
| 5005 | 密码已过期 | 需要修改密码 |

## 🔐 数据库表结构

### 用户表 (sys_user)

```sql
CREATE TABLE `sys_user` (
  `user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `dept_id` bigint(20) DEFAULT NULL COMMENT '部门ID',
  `user_name` varchar(30) NOT NULL COMMENT '用户账号',
  `nick_name` varchar(30) NOT NULL COMMENT '用户昵称',
  `user_type` varchar(2) DEFAULT '00' COMMENT '用户类型（00系统用户）',
  `email` varchar(50) DEFAULT '' COMMENT '用户邮箱',
  `phonenumber` varchar(11) DEFAULT '' COMMENT '手机号码',
  `sex` char(1) DEFAULT '0' COMMENT '用户性别（0男 1女 2未知）',
  `avatar` varchar(100) DEFAULT '' COMMENT '头像地址',
  `password` varchar(100) DEFAULT '' COMMENT '密码',
  `status` char(1) DEFAULT '0' COMMENT '帐号状态（0正常 1停用）',
  `del_flag` char(1) DEFAULT '0' COMMENT '删除标志（0代表存在 2代表删除）',
  `login_ip` varchar(128) DEFAULT '' COMMENT '最后登录IP',
  `login_date` datetime DEFAULT NULL COMMENT '最后登录时间',
  `is_first_login` tinyint(1) DEFAULT '1' COMMENT '是否首次登录（1是 0否）',
  `create_by` varchar(64) DEFAULT '' COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) DEFAULT '' COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户信息表';
```

### 登录日志表 (sys_logininfor)

```sql
CREATE TABLE `sys_logininfor` (
  `info_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '访问ID',
  `user_name` varchar(50) DEFAULT '' COMMENT '用户账号',
  `ipaddr` varchar(128) DEFAULT '' COMMENT '登录IP地址',
  `login_location` varchar(255) DEFAULT '' COMMENT '登录地点',
  `browser` varchar(50) DEFAULT '' COMMENT '浏览器类型',
  `os` varchar(50) DEFAULT '' COMMENT '操作系统',
  `status` char(1) DEFAULT '0' COMMENT '登录状态（0成功 1失败）',
  `msg` varchar(255) DEFAULT '' COMMENT '提示消息',
  `login_time` datetime DEFAULT NULL COMMENT '访问时间',
  PRIMARY KEY (`info_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统访问记录';
```

## 📝 配置文件

### application.yml

```yaml
# token配置
token:
  # 令牌自定义标识
  header: Authorization
  # 令牌密钥
  secret: abcdefghijklmnopqrstuvwxyz
  # 令牌有效期（默认30分钟）
  expireTime: 30

# 短信配置
sms:
  # 阿里云短信配置
  aliyun:
    accessKeyId: your_access_key_id
    accessKeySecret: your_access_key_secret
    signName: 科研管理系统
    templateCode: SMS_LOGIN_CODE

# Redis配置
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
    timeout: 10s
    lettuce:
      pool:
        min-idle: 0
        max-idle: 8
        max-active: 8
        max-wait: -1ms
```

---

**📝 说明**: 此接口文档基于RuoYi-Vue框架设计，提供完整的登录认证功能，包括账号密码登录、手机验证码登录、安全验证、Token管理等核心功能，确保系统安全性和用户体验。 